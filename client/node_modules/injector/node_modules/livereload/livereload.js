// Generated by CoffeeScript 1.3.2
(function() {
    var Server, defaultExclusions, defaultExts, defaultPort, fs, path, version, ws,
        __slice = [].slice;

    fs = require('fs');

    path = require('path');

    ws = require('websocket.io');

    version = '1.6';

    defaultPort = 41310;

    defaultExts = ['html', 'css', 'js', 'png', 'gif', 'jpg', 'php', 'php5', 'py', 'rb', 'erb', 'less', 'scss', 'coffee'];

    defaultExclusions = ['.git/', '.svn/', '.hg/'];

    Server = (function() {

        function Server(config) {
            var _base, _base1, _base2, _base3, _base4, _base5, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
            this.config = config;
            if ((_ref = this.config) == null) {
                this.config = {};
            }
            if ((_ref1 = (_base = this.config).version) == null) {
                _base.version = version;
            }
            if ((_ref2 = (_base1 = this.config).port) == null) {
                _base1.port = defaultPort;
            }
            if ((_ref3 = (_base2 = this.config).exts) == null) {
                _base2.exts = [];
            }
            if ((_ref4 = (_base3 = this.config).exclusions) == null) {
                _base3.exclusions = [];
            }
            this.config.exts = this.config.exts.concat(defaultExts);
            this.config.exclusions = this.config.exclusions.concat(defaultExclusions);
            if ((_ref5 = (_base4 = this.config).applyJSLive) == null) {
                _base4.applyJSLive = false;
            }
            if ((_ref6 = (_base5 = this.config).applyCSSLive) == null) {
                _base5.applyCSSLive = true;
            }
            this.sockets = [];
        }

        Server.prototype.listen = function() {
            this.debug("LiveReload is waiting for browser to connect.");
            this.server = ws.listen(this.config.port);
            this.server.on('connection', this.onConnection.bind(this));
            return this.server.on('close', this.onClose.bind(this));
        };

        Server.prototype.onConnection = function(socket) {
            var _this = this;
            this.debug("Browser connected.");
            socket.send("!!ver:" + this.config.version);
            socket.on('message', function(message) {
                return _this.debug("Browser URL: " + message);
            });
            return this.sockets.push(socket);
        };

        Server.prototype.onClose = function(socket) {
            return this.debug("Browser disconnected.");
        };

        Server.prototype.walkTree = function(dirname, callback) {
            var exclusions, exts, walk;
            exts = this.config.exts;
            exclusions = this.config.exclusions;
            walk = function(dirname) {
                return fs.readdir(dirname, function(err, files) {
                    if (err) {
                        return callback(err);
                    }
                    return files.forEach(function(file) {
                        var exclusion, filename, _i, _len;
                        filename = path.join(dirname, file);
                        for (_i = 0, _len = exclusions.length; _i < _len; _i++) {
                            exclusion = exclusions[_i];
                            if (filename.match(exclusion)) {
                                return;
                            }
                        }
                        return fs.stat(filename, function(err, stats) {
                            var ext, _j, _len1, _results;
                            if (!err && stats.isDirectory()) {
                                return walk(filename);
                            } else {
                                _results = [];
                                for (_j = 0, _len1 = exts.length; _j < _len1; _j++) {
                                    ext = exts[_j];
                                    if (!(filename.match("\." + ext + "$"))) {
                                        continue;
                                    }
                                    callback(err, filename);
                                    break;
                                }
                                return _results;
                            }
                        });
                    });
                });
            };
            return walk(dirname, callback);
        };

        var watchedFiles = Server.prototype.watchedFiles = [];
        var watchedFolders = Server.prototype.watchedFolders = [];

        Server.prototype.watch = function(dirname, rewatch) {
            var rewatch = rewatch || false;
            var _this = this;

            /* look for new files every 30 seconds */
            var interval;
            if(!rewatch) {
                console.log('huhu');
                setInterval(function(){
                    if(_this.watchedFolders.indexOf(dirname) > -1)
                        _this.watch(dirname, true);
                    else
                        clearInterval(this);
                }, 3000);
            }

            var index = this.watchedFolders.indexOf(dirname);
            if(index > -1) {
                if(!rewatch)
                    return;
            } else {
                this.watchedFolders.push(dirname);
            }

            return this.walkTree(dirname, function(err, filename) {
                if (err) {
                    throw err;
                }
                var file = _this.watchedFiles.filter(function(o){
                    return o.file === filename;
                });
                if(file.length > 0) {
                    return;
                }
                return _this.watchedFiles.push({
                    file: filename,
                    instance: fs.watchFile(filename, {interval : 500}, function(curr, prev) {
                        if (curr.mtime > prev.mtime) {
                            console.log(filename + ' changed!' );
                            return _this.refresh(filename);
                        }
                    })
                });
            });
        };

        Server.prototype.unwatch = function(dirname) {
            var _this = this;
            if(this.watchedFolders.indexOf(dirname) === -1) {
                return;
            }
            return this.walkTree(dirname, function(err, filename) {
                if (err) {
                    throw err;
                }
                _this.watchedFolders = _this.watchedFolders.filter(function(folder){
                    folder !== dirname;
                });
                var file = _this.watchedFiles.filter(function(o){
                    return o.file === filename;
                });
                if(file.length === 0) {
                    return;
                }
                file[0].instance.stop();
                return _this.watchedFiles = _this.watchedFiles.filter(function(file){
                    return file.file !== filename;
                })
            });
        }

        Server.prototype.unwatchAll = function() {
            this.watchedFiles.forEach(function(file){
                file.instance.stop();
            });
            this.watchedFiles = [];
            this.watchedFolders = [];
        }

        Server.prototype.refresh = function(path) {
            var data, socket, _i, _len, _ref, _results;
            this.debug("Refresh: " + path);
            data = JSON.stringify([
                'refresh', {
                    path: path,
                    apply_js_live: this.config.applyJSLive,
                    apply_css_live: this.config.applyCSSLive
                }
            ]);
            _ref = this.sockets;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                socket = _ref[_i];
                _results.push(socket.send(data));
            }
            return _results;
        };

        Server.prototype.debug = function(str) {
            if (this.config.debug) {
                return console.log("" + str + "\n");
            }
        };

        return Server;

    })();

    var sockserver;

    exports.createServer = function() {
        var args, server;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        server = (function(func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor,
                result = func.apply(child, args),
                t = typeof result;
            return t == "object" || t == "function" ? result || child : child;
        })(Server, args, function() {});
        server.listen();
        server.server.httpServer.on('close', function(){
            server.unwatchAll();
        })
        return sockserver = server;
    };

}).call(this);